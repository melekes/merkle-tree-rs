# Merkle Tree implemented in Rust programming language

Это одна из версий того, как может быть реализовано дерево Меркла.

Основная статья: https://en.wikipedia.org/wiki/Merkle_tree

### Формат хранения

Бинарное дерево располагается в массиве в порядке breadth-first. Начиная с
корневого узла идем слева направо на каждом уровне.

```
    1
  2   3
 4 5 6 7
```

Массив:

```
[1 2 3 4 5 6 7]
```

При формировании дерева, если на промежуточных уровнях нечетное кол-во узлов, то
последний узел дублируется. Иначе, дерево будет не полным (complete binary
tree). Условие полноты необходимо для описанной выше схемы хранения "2i 2i+1".

### Защита от потенциальных атак

Чтобы защититься от атаки нахождения второго прообраза, в момент вычисления хэша
к узлу добавляется: 0x00 - если он на нижнем уровне, 0x01 - если промежуточный или
корневой.

По умолчанию для хэширования используется SHA256. Но можно передать свою
реализацию (например, double SHA256).

### Использование

Допустим у вас есть файл. Вы разбиваете его на 100 кусков и строите дерево.

```rust
use merkle_tree::MerkleTree;

let t: merkletree = merkletree::build(&blocks);
```

В качестве блока может быть что угодно, до тех пор пока оно реализует trait
`AsBytes`. Для кодирования чисел есть библиотека
https://github.com/BurntSushi/byteorder . Если это уже массив байтов, ничего
делать не требуется.

Как уже упоминалось выше, можно передать свою хэш-функцию:

```
use merkle_tree::MerkleTree;

let t: merkletree = merkletree::build(&blocks, MyAwesomeHasher::new());
```

Дальше вы каким-то магическим образом безопасно копируете root hash.

```
magic(t.root_hash());
```

После этого можно скопировать элементы нижнего уровня (небезопасно, из любого
источника). Если они "сходятся" к root hash, то считаем их подлинными.

Осталось лишь запустить копирование нашего файла и по получении очередного блока
выполнять проверку:

```
assert!(t.verify(block_index, &block));
```

где `block_index` - индекс блока (начиная с 0).

## Decision log

### Почему бинарное дерево?

Ни в одном источнике не говориться, сколько дочерних узлов должно быть у предка.
Обычно выбирают 2. Получается, нам нужно знать только хэш соседнего узла, чтобы
проверить поддерево. И так вплоть до корневого узла. На каждом уровне нам нужен
лишь сосед справа (или слева). Это конечно, если нам требуется проверять log(N)
хэшей на пути к корню.

```
    1
  2   3
```

### Почему дерево упаковано в массив?

Чтобы достать родителя элемента, нужно лишь разделить индекс текущего узла
пополам: `5 / 2 = 2`.

## Usage

## Development

### Step 1. Create development environment

You will need [docker engine](https://docs.docker.com/engine/installation/) if
you want to develop this library inside a container. If you already have rust
on your computer and fine with downloading some dependencies, feel free to skip
this step.

```
$ make create_dev_env
$ make run_shell
```

### Step 2. Build & test

```
$ cargo build --features "dev"
$ cargo test
```
